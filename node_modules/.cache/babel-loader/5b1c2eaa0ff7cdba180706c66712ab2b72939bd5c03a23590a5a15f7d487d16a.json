{"ast":null,"code":"import { Delaunay } from \"d3-delaunay\";\nimport { scaleLinear } from \"d3-scale\";\nimport extent from \"./extent.js\";\nimport merge from \"./merge.js\";\nimport planarRingsort from \"./ringsort.js\";\nexport default function () {\n  // accessors\n  let x = d => d[0],\n    y = d => d[1],\n    value = d => isFinite(+d[2]) ? +d[2] : 0,\n    triangulate = Delaunay.from,\n    pointInterpolate = (i, j, a) => {\n      const {\n        points\n      } = triangulation;\n      const A = [points[2 * i], points[2 * i + 1]],\n        B = [points[2 * j], points[2 * j + 1]];\n      return [a * B[0] + (1 - a) * A[0], a * B[1] + (1 - a) * A[1]];\n    },\n    ringsort = planarRingsort;\n  let thresholds, values, triangulation;\n  function init(points) {\n    triangulation = triangulate(points, x, y);\n    values = Array.from(points, value);\n    if (typeof thresholds !== \"object\") {\n      thresholds = scaleLinear().domain(extent(values)).nice().ticks(thresholds);\n    }\n  }\n  function* tricontours(points) {\n    init(points);\n    for (const threshold of thresholds) {\n      const polygon = tricontour(triangulation, values, threshold);\n      yield {\n        type: \"MultiPolygon\",\n        coordinates: polygon,\n        value: threshold\n      };\n    }\n  }\n  function contour(points, threshold) {\n    init(points);\n    return {\n      type: \"MultiPolygon\",\n      coordinates: tricontour(triangulation, values, threshold),\n      value: threshold\n    };\n  }\n  function* isobands(points) {\n    init(points);\n    let p0, p1, th0;\n    for (const th of thresholds) {\n      if (p1) p0 = p1;\n      p1 = merge(tricontour(triangulation, values, th));\n      if (p0) {\n        yield {\n          type: \"MultiPolygon\",\n          coordinates: ringsort(p0.concat(p1.map(ring => ring.slice().reverse()))),\n          value: th0,\n          valueMax: th\n        };\n      }\n      th0 = th;\n    }\n  }\n  const contours = function (data) {\n    return [...tricontours(data)];\n  };\n\n  // API\n  contours.x = _ => _ ? (x = _, contours) : x;\n  contours.y = _ => _ ? (y = _, contours) : y;\n  contours.value = _ => _ ? (value = _, contours) : value;\n  contours.thresholds = _ => _ ? (thresholds = _, contours) : thresholds;\n  contours.triangulate = _ => _ ? (triangulate = _, contours) : triangulate;\n  contours.pointInterpolate = _ => _ ? (pointInterpolate = _, contours) : pointInterpolate;\n  contours.ringsort = _ => _ ? (ringsort = _, contours) : ringsort;\n  contours.contours = tricontours;\n  contours.contour = contour;\n  contours.isobands = isobands;\n\n  // expose the internals (useful for debugging, not part of the API)\n  contours._values = () => values;\n  contours._triangulation = () => triangulation;\n  return contours;\n\n  // navigate a triangle\n  function next(i) {\n    return i % 3 === 2 ? i - 2 : i + 1;\n  }\n  function prev(i) {\n    return i % 3 === 0 ? i + 2 : i - 1;\n  }\n  function tricontour(triangulation, values) {\n    let v0 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    // sanity check\n    for (const d of values) if (!isFinite(d)) throw [\"Invalid value\", d];\n    const {\n        halfedges,\n        hull,\n        inedges,\n        triangles\n      } = triangulation,\n      n = values.length;\n    function edgealpha(i) {\n      return alpha(triangles[i], triangles[next(i)]);\n    }\n    function alpha(i, j) {\n      const u = values[i],\n        v = values[j];\n      if (u <= v0 && v >= v0 && u < v) {\n        return (v0 - u) / (v - u);\n      }\n    }\n\n    // create the path from the first exit; cancel visited halfedges\n    const rings = [],\n      visited = new Uint8Array(halfedges.length).fill(0);\n    let path, i, j, k, a;\n    for (k = 0; k < halfedges.length; k++) {\n      if (visited[k]) continue;\n      i = k;\n      path = [];\n      while ((a = edgealpha(i)) > 0) {\n        const [ti, tj] = [triangles[i], triangles[j = next(i)]];\n\n        // is our tour done?\n        if (path.length && ti === path[0].ti && tj === path[0].tj || path.length > 2 * n) break;\n        visited[i] = 1;\n        path.push({\n          ti,\n          tj,\n          a\n        });\n\n        // jump into the adjacent triangle\n        if ((j = halfedges[i]) > -1) {\n          if (edgealpha(j = next(j)) > 0) {\n            i = j;\n            continue;\n          }\n          if (edgealpha(j = next(j)) > 0) {\n            i = j;\n            continue;\n          }\n          // debugger;\n        }\n\n        // or follow the hull\n        else {\n          let h = (hull.indexOf(triangles[i]) + 1) % hull.length;\n          while (values[hull[h]] < v0) {\n            // debugger;\n            h = (h + 1) % hull.length;\n          }\n          while (values[hull[h]] >= v0) {\n            path.push({\n              ti: hull[h],\n              tj: hull[h],\n              a: 0\n            });\n            h = (h + 1) % hull.length;\n          }\n\n          // take that entry\n          j = inedges[hull[h]];\n          path.push({\n            ti: hull[h],\n            tj: triangles[j],\n            a: alpha(hull[h], triangles[j])\n          });\n          if (edgealpha(i = next(j)) > 0) continue;\n          if (edgealpha(i = prev(j)) > 0) continue;\n        }\n      }\n      if (path.length) {\n        path.push(path[0]);\n        rings.push(path.map(_ref => {\n          let {\n            ti,\n            tj,\n            a\n          } = _ref;\n          return pointInterpolate(ti, tj, a);\n        }));\n      }\n    }\n\n    // special case all values on the hull are >=v0, add the hull\n    if (hull.every(d => values[d] >= v0)) {\n      rings.unshift(Array.from(hull).concat([hull[0]]).map(i => pointInterpolate(i, i, 0)));\n    }\n    return ringsort(rings); // return [rings] if we don't need to sort\n  }\n}","map":{"version":3,"names":["Delaunay","scaleLinear","extent","merge","planarRingsort","x","d","y","value","isFinite","triangulate","from","pointInterpolate","i","j","a","points","triangulation","A","B","ringsort","thresholds","values","init","Array","domain","nice","ticks","tricontours","threshold","polygon","tricontour","type","coordinates","contour","isobands","p0","p1","th0","th","concat","map","ring","slice","reverse","valueMax","contours","data","_","_values","_triangulation","next","prev","v0","arguments","length","undefined","halfedges","hull","inedges","triangles","n","edgealpha","alpha","u","v","rings","visited","Uint8Array","fill","path","k","ti","tj","push","h","indexOf","_ref","every","unshift"],"sources":["/home/logan-lapierre/Desktop/personal_projects/lupenox-systems/node_modules/d3-tricontour/src/tricontour.js"],"sourcesContent":["import {Delaunay} from \"d3-delaunay\";\nimport {scaleLinear} from \"d3-scale\";\nimport extent from \"./extent.js\";\nimport merge from \"./merge.js\";\nimport planarRingsort from \"./ringsort.js\";\n\nexport default function() {\n  // accessors\n  let x = d => d[0],\n    y = d => d[1],\n    value = d => (isFinite(+d[2]) ? +d[2] : 0),\n    triangulate = Delaunay.from,\n    pointInterpolate = (i, j, a) => {\n      const { points } = triangulation;\n      const A = [points[2 * i], points[2 * i + 1]],\n        B = [points[2 * j], points[2 * j + 1]];\n      return [a * B[0] + (1 - a) * A[0], a * B[1] + (1 - a) * A[1]];\n    },\n    ringsort = planarRingsort;\n\n  let thresholds, values, triangulation;\n\n  function init(points) {\n    triangulation = triangulate(points, x, y);\n    values = Array.from(points, value);\n    if (typeof thresholds !== \"object\") {\n      thresholds = scaleLinear()\n        .domain(extent(values))\n        .nice()\n        .ticks(thresholds);\n    }\n  }\n\n  function* tricontours(points) {\n    init(points);\n\n    for (const threshold of thresholds) {\n      const polygon = tricontour(triangulation, values, threshold);\n      yield {\n        type: \"MultiPolygon\",\n        coordinates: polygon,\n        value: threshold\n      };\n    }\n  }\n\n  function contour(points, threshold) {\n    init(points);\n\n    return {\n      type: \"MultiPolygon\",\n      coordinates: tricontour(triangulation, values, threshold),\n      value: threshold\n    };\n  }\n\n  function* isobands(points) {\n    init(points);\n\n    let p0, p1, th0;\n    for (const th of thresholds) {\n      if (p1) p0 = p1;\n      p1 = merge(tricontour(triangulation, values, th));\n      if (p0) {\n        yield {\n          type: \"MultiPolygon\",\n          coordinates: ringsort(\n            p0.concat(p1.map(ring => ring.slice().reverse()))\n          ),\n          value: th0,\n          valueMax: th\n        };\n      }\n      th0 = th;\n    }\n  }\n\n  const contours = function(data) {\n    return [...tricontours(data)];\n  };\n\n  // API\n  contours.x = _ => (_ ? ((x = _), contours) : x);\n  contours.y = _ => (_ ? ((y = _), contours) : y);\n  contours.value = _ => (_ ? ((value = _), contours) : value);\n  contours.thresholds = _ => (_ ? ((thresholds = _), contours) : thresholds);\n  contours.triangulate = _ => (_ ? ((triangulate = _), contours) : triangulate);\n  contours.pointInterpolate = _ =>\n    _ ? ((pointInterpolate = _), contours) : pointInterpolate;\n  contours.ringsort = _ =>\n    _ ? ((ringsort = _), contours) : ringsort;\n  contours.contours = tricontours;\n  contours.contour = contour;\n  contours.isobands = isobands;\n\n  // expose the internals (useful for debugging, not part of the API)\n  contours._values = () => values;\n  contours._triangulation = () => triangulation;\n\n  return contours;\n\n  // navigate a triangle\n  function next(i) {\n    return i % 3 === 2 ? i - 2 : i + 1;\n  }\n  function prev(i) {\n    return i % 3 === 0 ? i + 2 : i - 1;\n  }\n\n  function tricontour(triangulation, values, v0 = 0) {\n    // sanity check\n    for (const d of values) if (!isFinite(d)) throw [\"Invalid value\", d];\n\n    const { halfedges, hull, inedges, triangles } = triangulation,\n      n = values.length;\n\n    function edgealpha(i) {\n      return alpha(triangles[i], triangles[next(i)]);\n    }\n    function alpha(i, j) {\n      const u = values[i],\n        v = values[j];\n      if (u <= v0 && v >= v0 && u < v) {\n        return (v0 - u) / (v - u);\n      }\n    }\n\n    // create the path from the first exit; cancel visited halfedges\n    const rings = [],\n      visited = new Uint8Array(halfedges.length).fill(0);\n    let path, i, j, k, a;\n    for (k = 0; k < halfedges.length; k++) {\n      if (visited[k]) continue;\n\n      i = k;\n      path = [];\n\n      while ((a = edgealpha(i)) > 0) {\n        const [ti, tj] = [triangles[i], triangles[(j = next(i))]];\n\n        // is our tour done?\n        if (\n          (path.length && (ti === path[0].ti && tj === path[0].tj)) ||\n          path.length > 2 * n\n        )\n          break;\n\n        visited[i] = 1;\n        path.push({ ti, tj, a });\n\n        // jump into the adjacent triangle\n        if ((j = halfedges[i]) > -1) {\n          if (edgealpha((j = next(j))) > 0) {\n            i = j;\n            continue;\n          }\n          if (edgealpha((j = next(j))) > 0) {\n            i = j;\n            continue;\n          }\n          // debugger;\n        }\n\n        // or follow the hull\n        else {\n          let h = (hull.indexOf(triangles[i]) + 1) % hull.length;\n\n          while (values[hull[h]] < v0) {\n            // debugger;\n            h = (h + 1) % hull.length;\n          }\n\n          while (values[hull[h]] >= v0) {\n            path.push({ ti: hull[h], tj: hull[h], a: 0 });\n            h = (h + 1) % hull.length;\n          }\n\n          // take that entry\n          j = inedges[hull[h]];\n          path.push({\n            ti: hull[h],\n            tj: triangles[j],\n            a: alpha(hull[h], triangles[j])\n          });\n\n          if (edgealpha((i = next(j))) > 0) continue;\n          if (edgealpha((i = prev(j))) > 0) continue;\n        }\n      }\n\n      if (path.length) {\n        path.push(path[0]);\n        rings.push(path.map(({ ti, tj, a }) => pointInterpolate(ti, tj, a)));\n      }\n    }\n\n    // special case all values on the hull are >=v0, add the hull\n    if (hull.every(d => values[d] >= v0)) {\n      rings.unshift(\n        Array.from(hull)\n          .concat([hull[0]])\n          .map(i => pointInterpolate(i, i, 0))\n      );\n    }\n\n    return ringsort(rings); // return [rings] if we don't need to sort\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}